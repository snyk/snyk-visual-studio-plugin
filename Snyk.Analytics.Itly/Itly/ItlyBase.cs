// 
// ItlyBase.cs
// 
// This file is auto-generated by Amplitude.
// To update run 'ampli pull visual-studio-plugin'
// 
// Questions? We're here to help:
// https://developers.data.amplitude.com/dotnet
// 

using System;
using System.Collections.Generic;
using Manatee.Json;
using Manatee.Json.Schema;
using Manatee.Json.Serialization;

namespace Iteratively
{
    internal abstract class ItlyBase
    {
        private Properties Properties { get; }
        private Context Context { get; }
        private bool Disabled { get; }
        protected Environment Environment { get; }
        protected ILogger Logger { get; }
        private ValidationOptions Validation { get; }

        private Dictionary<string, JsonSchema> Validators { get; } = new Dictionary<string, JsonSchema>();
        private Dictionary<Vendor, IDestination> Adapters { get; } = new Dictionary<Vendor, IDestination>();
        private Dictionary<Vendor, object> Clients { get; } = new Dictionary<Vendor, object>();
        private JsonSerializer _serializer = JsonSerializerFactory.Create();

        protected ItlyBase(Dictionary<string, string> schemas,
            Properties properties,
            Context context,
            bool disabled,
            Environment environment,
            ILogger logger,
            ValidationOptions validation)
        {
            Properties = properties;
            Context = context;
            Disabled = disabled;
            Environment = environment;
            Logger = logger;
            Validation = validation;

            CreateValidators(schemas);
            Validate(context);
        }

        private void CreateValidators(Dictionary<string, string> schemas)
        {
            foreach (var item in schemas)
            {
                var schemaKey = item.Key;
                var rawSchema = item.Value;
                var jsonSchema = JsonValue.Parse(rawSchema);
                var schema = _serializer.Deserialize<JsonSchema>(jsonSchema);
                var validationResult = schema.ValidateSchema();
                if (!validationResult.IsValid)
                    throw new ArgumentException($"Invalid schema {schemaKey}", nameof(schemas));
                Validators[item.Key] = schema;
            }
        }

        private void Validate(Event @event)
        {
            if (Validation.Disabled)
                return;

            var eventJson = @event.ToJson(_serializer);

            // Shortcut events with no properties, aka "{}"
            if (eventJson.Type == JsonValueType.Object && eventJson.Object.Count == 0)
                return;

            var validationResult = Validators[@event.Schema].Validate(eventJson);
            if (validationResult.IsValid)
                return;
            
            var message = $"Error validating event {@event.Name}: {validationResult.RelativeLocation} {validationResult.AdditionalInfo}";
            Logger.Error($"(Itly) {message}");
            if (Validation.FailOnError)
                throw new ValidationException(message);
        }

        protected void RegisterAdapter(Vendor vendor, IDestination adapter)
        {
            Adapters[vendor] = adapter;
        }

        protected void InitAdapters()
        {
            if (Disabled)
                return;

            ForEachAdapter("init", adapter => adapter.Init());
            foreach (var item in Adapters)
            {
                var clientDestination = item.Value as IClientDestination;
                Clients[item.Key] = clientDestination?.Client();
            }
        }

        private void ForEachAdapter(string actionName, Action<IDestination> action)
        {
            foreach (var adapter in Adapters.Values)
            {
                try
                {
                    action(adapter);
                }
                catch (Exception ex)
                {
                    Logger.Error($"(Itly) Error {actionName} in {adapter.GetType().Name}: {ex}");
                }
            }
        }

        internal T Client<T>(Vendor vendor)
        {
            return (T)Clients[vendor];
        }

        internal void Alias(string userId, string previousId)
        {
            if (Disabled)
                return;

            ForEachAdapter("alias", adapter => adapter.Alias(userId, previousId));
        }

        internal void Identify(string userId, Identify properties)
        {
            if (Disabled)
                return;

            Validate(properties);
            ForEachAdapter("identify", adapter => adapter.Identify(userId, properties));
        }

        internal void Group(string userId, string groupId, Group properties)
        {
            if (Disabled)
                return;

            Validate(properties);
            ForEachAdapter("group", adapter => adapter.Group(userId, groupId, properties));
        }

        internal void Track(string userId, string eventName, Event @event)
        {
            if (Disabled)
                return;

            Validate(@event);
            var combined = Properties.Concatenate(Context, @event, Properties,
                new Properties(new Dictionary<string, object> {}));
            ForEachAdapter("group", adapter => adapter.Track(userId, eventName, combined));
        }

        internal void Dispose()
        {
            if (Disabled)
                return;

            ForEachAdapter("dispose", adapter => adapter.Dispose());
        }
    }

    internal sealed class DestinationConfiguration
    {
        public object Options { get; }
        public Dictionary<Environment, string> Keys { get; }

        public DestinationConfiguration(object options, Dictionary<Environment, string> keys)
        {
            Options = options;
            Keys = keys;
        }
    }

    /// <summary>
    /// Configurable options for validation.
    /// </summary>
    public sealed class ValidationOptions
    {
        public bool Disabled { get; }
        public bool FailOnError { get; }

        /// <summary>
        /// Create new ValidationOptions.
        /// <param name="disabled">Disable validation.</param>
        /// <param name="failOnError">Fail on any internal Itly errors.</param>
        /// </summary>
        public ValidationOptions(bool disabled = false, bool failOnError = false)
        {
            Disabled = disabled;
            FailOnError = failOnError;
        }
    }
}