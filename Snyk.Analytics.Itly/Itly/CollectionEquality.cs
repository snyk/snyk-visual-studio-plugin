// 
// CollectionEquality.cs
// 
// This file is auto-generated by Amplitude.
// To update run 'ampli pull visual-studio-plugin'
// 
// Questions? We're here to help:
// https://developers.data.amplitude.com/dotnet
// 

using System.Collections.Generic;
using System.Linq;

namespace Iteratively
{
    partial class CollectionUtils
    {
        private static EqualityComparer<object> _valueComparer = EqualityComparer<object>.Default;

        private static bool isDictionary(object maybeDictionary) =>
            maybeDictionary.GetType().Equals(typeof(Dictionary<string, object>));

        private static Dictionary<string, object> asDictionary(object o) =>
            o as Dictionary<string, object>;

        private static ICollection<object> asCollection(object o) =>
            o as ICollection<object>;

        private static List<object> asList(object o) =>
            o as List<object>;

        public static int GetHashCode(object obj)
        {
            int code = 0;

            if (obj == null)
              return code;

            var aDictionary = asDictionary(obj);
            var aCollection = asCollection(obj);

            if (aDictionary != null)
              foreach(var kvp in aDictionary) {
                code += kvp.Key.GetHashCode();
                code += GetHashCode(kvp.Value);
              }
            else if (aCollection != null)
              foreach(var item in aCollection)
                code += GetHashCode(item);
            else
              code += obj.GetHashCode();

            return code;
        }

        /// <summary>
        ///
        /// There is no pre-given implementation of .Equals
        /// that deeply compares based on value instead of
        /// reference. The standard .Equals only returns
        /// true if the two Dictionaries are the same object
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public static bool CollectionsAreEqual(object a, object b)
        {
            if ((a.Equals(b)))
                return true;
            if ((a == null | b == null))
                return true;
            var aCollection = asCollection(a);
            var bCollection = asCollection(b);
            if (aCollection != null && bCollection != null
                && aCollection.Count() != bCollection.Count())
                return false;
            if ((!a.GetType().Equals(b.GetType())))
                return false;

            var aDictionary = asDictionary(a);
            if (aDictionary != null)
                return CollectionDictionariesAreEqualHelper(
                  aDictionary, asDictionary(b)
                );

            var aList = asList(a);
            if (aList != null)
                return CollectionListsAreEqualHelper(
                  aList, asList(b)
                );

            if (aCollection != null)
                return CollectionListsAreEqualHelper(
                  aCollection.ToList(), bCollection.ToList()
                );

            // Nothing to iterate over, we should have returned before getting here
            return a.Equals(b);
        }

        private static bool CollectionDictionariesAreEqualHelper(Dictionary<string, object> a, Dictionary<string, object> b)
        {
            bool result = true;

            foreach (KeyValuePair<string, object> kvp in a)
            {
                object valueA = kvp.Value;
                object valueB;

                // if the second dictionary has the key
                if ((!b.TryGetValue(kvp.Key, out valueB)))
                    return false;

                // We don't care what a and b are, but the CollectionsAreEqual
                // Function should take care of every case of object
                result = (result & CollectionsAreEqual(valueA, valueB));

                // Terminate if this loop caused an inequality
                if ((!result))
                    return false;
            }

            return result;
        }

        private static bool CollectionListsAreEqualHelper(List<object> a, List<object> b)
        {
            bool result = true;

            int i;
            for (i = 0; i <= a.Count - 1; i++)
            {
                object valueA = a[i];
                object valueB = b[i];

                // We don't care what a and b are, but the CollectionsAreEqual
                // Function should take care of every case of object
                result = (result & CollectionsAreEqual(valueA, valueB));
                if ((!result))
                    return false;
            }

            return result;
        }
    }
}
